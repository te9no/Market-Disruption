import { Game, Ctx } from 'boardgame.io';
import { GameState, initialGameState, createInitialPlayer, Player, Product, Design } from './GameState';

const rollDice = (sides: number = 6): number => Math.floor(Math.random() * sides) + 1;
const rollMultipleDice = (count: number, sides: number = 6): number[] => 
  Array.from({ length: count }, () => rollDice(sides));

const getDemandValue = (cost: number): number[] => {
  const demandMap: { [key: number]: number[] } = {
    1: [6, 7, 8],
    2: [5, 9], 
    3: [4, 10],
    4: [3, 11],
    5: [2, 12]
  };
  return demandMap[cost] || [];
};

const checkVictoryConditions = (player: Player): boolean => {
  return (player.prestige >= 17 && player.money >= 75) || player.money >= 150;
};

const MarketDisruption: Game<GameState> = {
  name: 'MarketDisruption',
  
  setup: ({ ctx }) => {
    const G = { ...initialGameState };
    
    for (let i = 0; i < ctx.numPlayers; i++) {
      const playerId = String(i);
      G.players[playerId] = createInitialPlayer(playerId, `Player ${i + 1}`);
      
      const designDice = rollMultipleDice(2);
      G.players[playerId].designs = designDice.map((cost, index) => ({
        id: `design-${playerId}-${index}`,
        cost,
        isOpenSource: false
      }));
    }
    
    return G;
  },

  moves: {
    manufacture: ({ G, ctx }, designId: string) => manufacture(G, ctx, designId),
    sell: ({ G, ctx }, productId: string, price: number) => sell(G, ctx, productId, price),
    purchase: ({ G, ctx }, targetPlayerId: string, productId: string) => purchase(G, ctx, targetPlayerId, productId),
    review: ({ G, ctx }, targetPlayerId: string, productId: string, isPositive: boolean) => review(G, ctx, targetPlayerId, productId, isPositive),
    research: ({ G, ctx }) => research(G, ctx),
    partTimeWork: ({ G, ctx }) => partTimeWork(G, ctx),
    buyBack: ({ G, ctx }, productId: string) => buyBack(G, ctx, productId),
    discontinue: ({ G, ctx }, designId: string) => discontinue(G, ctx, designId),
    resale: ({ G, ctx }, targetPlayerId: string, productId: string, resalePrice: number) => resale(G, ctx, targetPlayerId, productId, resalePrice),
    design: ({ G, ctx }, isOpenSource: boolean = false) => design(G, ctx, isOpenSource),
    promoteRegulation: ({ G, ctx }) => promoteRegulation(G, ctx),
    dayLabor: ({ G, ctx }) => dayLabor(G, ctx),
    activateTrend: ({ G, ctx }) => activateTrend(G, ctx)
  },


  endIf: ({ G }) => {
    if (G.gameEnded) {
      return { winner: G.winner };
    }
  },

  minPlayers: 1,
  maxPlayers: 4,
  
  // ÂàùÊúü„Éï„Çß„Éº„Ç∫„Çíaction„Å´Ë®≠ÂÆö
  phases: {
    action: {
      start: true,  // „Åì„Çå„ÅåÂàùÊúü„Éï„Çß„Éº„Ç∫„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊòéÁ§∫
      next: 'automata',
      turn: {
        order: {
          first: () => 0,
          next: ({ ctx }) => {
            // 1‰∫∫„Éó„É¨„Ç§„ÅÆÂ†¥Âêà„ÅØÂ∏∏„Å´Âêå„Åò„Éó„É¨„Ç§„É§„ÉºÔºà„Ç™„Éº„Éà„Éû„Å®„ÅÆÂØæÊà¶Ôºâ
            if (ctx.numPlayers === 1) {
              return 0;
            }
            // Ë§áÊï∞‰∫∫„Éó„É¨„Ç§„ÅÆÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆÈ†ÜÁï™
            return (ctx.playOrderPos + 1) % ctx.numPlayers;
          },
        }
      },
      // „Éï„Çß„Éº„Ç∫ÁµÇ‰∫Ü„ÅØÊâãÂãï„ÅßÂà∂Âæ°Ôºà„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÊôÇÔºâ
      endIf: () => false,
      onEnd: ({ G }) => {
        console.log('Action phase ending - resetting AP for all players');
        // ÂÖ®„Éó„É¨„Ç§„É§„Éº„ÅÆAP„Çí„É™„Çª„ÉÉ„Éà
        for (const playerId in G.players) {
          G.players[playerId].actionPoints = 3;
        }
      }
    },

    automata: {
      moves: {},
      onBegin: ({ G, events }) => {
        console.log('ü§ñ Automata phase started: executing automata actions');
        executeManufacturerAutomata(G);
        executeResaleAutomata(G);
        
        // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÊ¨°„ÅÆ„Éï„Çß„Éº„Ç∫„Å´ÈÄ≤„ÇÄ
        console.log('‚è∞ Scheduling transition to market phase in 2000ms');
        setTimeout(() => {
          console.log('üîÑ Transitioning from automata to market phase');
          if (events && events.endPhase) {
            events.endPhase();
          } else {
            console.error('‚ùå events.endPhase not available in automata phase');
          }
        }, 2000);
      },
      next: 'market'
    },

    market: {
      moves: {},
      onBegin: ({ G, events }) => {
        console.log('üè™ Market phase started: executing market actions');
        executeMarketPhase(G);
        
        // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÊ¨°„ÅÆ„Éï„Çß„Éº„Ç∫„Å´ÈÄ≤„ÇÄ
        console.log('‚è∞ Scheduling transition to action phase in 2000ms');
        setTimeout(() => {
          console.log('üîÑ Transitioning from market to action phase');
          if (events && events.endPhase) {
            events.endPhase();
          } else {
            console.error('‚ùå events.endPhase not available in market phase');
          }
        }, 2000);
      },
      next: 'action',
      onEnd: ({ G }) => {
        G.round++;
        console.log(`üéÆ Starting round ${G.round}`);
        
        // ÂãùÂà©Êù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ
        for (const playerId in G.players) {
          if (checkVictoryConditions(G.players[playerId])) {
            G.gameEnded = true;
            G.winner = playerId;
            G.phase = 'victory';
            console.log(`üèÜ Game ended! Winner: ${G.players[playerId].name}`);
            break;
          }
        }
      }
    },

    victory: {
      moves: {},
      turn: {
        order: {
          first: () => 0,
          next: () => undefined,
        }
      }
    }
  },
  
  turn: {
    order: {
      first: () => 0,
      next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.numPlayers,
    }
  },
  
  // „Éï„Çß„Éº„Ç∫ÁµÇ‰∫ÜÁî®„ÅÆ„Ç§„Éô„É≥„Éà
  events: {
    endPhase: true,
    endTurn: true
  }
};

function manufacture(G: GameState, ctx: Ctx, designId: string) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøË£ΩÈÄ†ÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  const design = player.designs.find(d => d.id === designId);
  if (!design) return 'INVALID_MOVE';
  
  if (player.money < design.cost) return 'INVALID_MOVE';
  
  player.money -= design.cost;
  player.actionPoints -= 1;
  
  const product: Product = {
    id: `product-${ctx.currentPlayer}-${Date.now()}`,
    cost: design.cost,
    price: 0, // Price not set yet, will be set when selling
    popularity: 1,
    playerId: ctx.currentPlayer,
    isResale: false
  };
  
  player.personalMarket.push(product);
}

function sell(G: GameState, ctx: Ctx, productId: string, price: number) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  if (player.prestige <= -3) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøË≤©Â£≤ÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  const productIndex = player.personalMarket.findIndex(p => p.id === productId && p.price === 0);
  if (productIndex === -1) return 'INVALID_MOVE';
  
  const product = player.personalMarket[productIndex];
  const maxPrice = getMaxPrice(product.cost, player.prestige);
  
  if (price > maxPrice) return 'INVALID_MOVE';
  
  product.price = price;
  player.actionPoints -= 1;
}

function getMaxPrice(cost: number, prestige: number): number {
  if (prestige >= 9) return cost * 4;
  if (prestige >= 3) return cost * 3;
  return cost * 2;
}

function purchase(G: GameState, ctx: Ctx, targetPlayerId: string, productId: string) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøË≥ºÂÖ•ÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  // „Ç™„Éº„Éà„Éû„Åã„Çâ„ÅÆË≥ºÂÖ•„ÅÆÂ†¥Âêà
  if (targetPlayerId === 'automata') {
    const productIndex = G.automata.market.findIndex(p => p.id === productId);
    if (productIndex === -1) return 'INVALID_MOVE';
    
    const product = G.automata.market[productIndex];
    if (player.money < product.price) return 'INVALID_MOVE';
    
    player.money -= product.price;
    player.actionPoints -= 1;
    
    // „Ç™„Éº„Éà„Éû„ÅÆÂïÜÂìÅ„ÇíÂâäÈô§
    G.automata.market.splice(productIndex, 1);
    return;
  }
  
  // „Éó„É¨„Ç§„É§„Éº„Åã„Çâ„ÅÆË≥ºÂÖ•„ÅÆÂ†¥Âêà
  const targetPlayer = G.players[targetPlayerId];
  if (!targetPlayer) return 'INVALID_MOVE';
  
  const productIndex = targetPlayer.personalMarket.findIndex(p => p.id === productId);
  if (productIndex === -1) return 'INVALID_MOVE';
  
  const product = targetPlayer.personalMarket[productIndex];
  if (player.money < product.price) return 'INVALID_MOVE';
  
  player.money -= product.price;
  targetPlayer.money += product.price;
  player.actionPoints -= 1;
  
  targetPlayer.personalMarket.splice(productIndex, 1);
}

function executeManufacturerAutomata(G: GameState): void {
  const diceSum = rollDice() + rollDice();
  
  let action: string;
  if (diceSum <= 4) action = 'high-cost';
  else if (diceSum <= 7) action = 'mid-cost';
  else if (diceSum <= 10) action = 'low-cost';
  else action = 'clearance';
  
  if (action === 'clearance') {
    for (const product of G.automata.market) {
      product.price = Math.max(1, product.price - 2);
    }
  } else {
    let targetCost: number;
    if (action === 'high-cost') {
      do { targetCost = rollDice(); } while (targetCost < 3);
    } else if (action === 'mid-cost') {
      targetCost = 3;
    } else {
      do { targetCost = rollDice(); } while (targetCost > 3);
    }
    
    const product: Product = {
      id: `automata-product-${Date.now()}`,
      cost: targetCost,
      price: targetCost * (action === 'high-cost' ? 3 : 2),
      popularity: 1,
      playerId: 'manufacturer-automata',
      isResale: false
    };
    
    G.automata.market.push(product);
  }
}

function executeResaleAutomata(G: GameState): void {
  if (G.automata.resaleOrganizationMoney < 20) {
    G.automata.resaleOrganizationMoney = 20;
  }
  
  const diceSum = rollDice() + rollDice();
  
  if (diceSum >= 6 && diceSum <= 8) return;
  
  const allProducts: Product[] = [];
  for (const playerId in G.players) {
    allProducts.push(...G.players[playerId].personalMarket);
  }
  allProducts.push(...G.automata.market);
  
  let targetProducts: Product[] = [];
  
  if (diceSum <= 4) {
    targetProducts = allProducts
      .sort((a, b) => a.price - b.price || b.popularity - a.popularity)
      .slice(0, 3);
  } else if (diceSum === 5 || diceSum === 9) {
    targetProducts = allProducts
      .sort((a, b) => b.popularity - a.popularity || a.price - b.price)
      .slice(0, 1);
  } else if (diceSum >= 10) {
    const randomIndex = Math.floor(Math.random() * allProducts.length);
    targetProducts = [allProducts[randomIndex]];
  }
  
  for (const product of targetProducts) {
    if (G.automata.resaleOrganizationMoney >= product.price) {
      G.automata.resaleOrganizationMoney -= product.price;
      
      const resaleProduct: Product = {
        ...product,
        id: `resale-${Date.now()}`,
        price: product.price + 5,
        isResale: true,
        originalCost: product.cost,
        originalPlayerId: product.playerId,
        playerId: 'resale-automata'
      };
      
      G.automata.market.push(resaleProduct);
      
      const originalPlayer = G.players[product.playerId];
      if (originalPlayer) {
        originalPlayer.money += product.price;
        const productIndex = originalPlayer.personalMarket.findIndex(p => p.id === product.id);
        if (productIndex !== -1) {
          originalPlayer.personalMarket.splice(productIndex, 1);
        }
      }
      
      G.marketPollution++;
    }
  }
}

function executeMarketPhase(G: GameState): void {
  const demandDice = rollDice() + rollDice();
  
  const allProducts: Product[] = [];
  for (const playerId in G.players) {
    allProducts.push(...G.players[playerId].personalMarket);
  }
  allProducts.push(...G.automata.market);
  
  const eligibleProducts = allProducts.filter(product => {
    const demandValues = getDemandValue(product.cost);
    return demandValues.includes(demandDice);
  });
  
  eligibleProducts.sort((a, b) => b.popularity - a.popularity || a.price - b.price);
  
  const purchasedProducts = eligibleProducts.slice(0, 5);
  
  for (const product of purchasedProducts) {
    const actualPrice = Math.max(1, product.price - getPollutionPenalty(G.marketPollution));
    
    if (product.playerId === 'manufacturer-automata' || product.playerId === 'resale-automata') {
      const productIndex = G.automata.market.findIndex(p => p.id === product.id);
      if (productIndex !== -1) {
        G.automata.market.splice(productIndex, 1);
      }
    } else {
      const player = G.players[product.playerId];
      if (player) {
        player.money += actualPrice;
        const productIndex = player.personalMarket.findIndex(p => p.id === product.id);
        if (productIndex !== -1) {
          player.personalMarket.splice(productIndex, 1);
        }
      }
    }
  }
}

function getPollutionPenalty(pollutionLevel: number): number {
  if (pollutionLevel <= 2) return 0;
  if (pollutionLevel <= 5) return 1;
  if (pollutionLevel <= 8) return 2;
  if (pollutionLevel <= 11) return 3;
  return 4;
}

function review(G: GameState, ctx: Ctx, targetPlayerId: string, productId: string, isPositive: boolean) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  if (player.prestige < 1) return 'INVALID_MOVE';
  
  const targetPlayer = G.players[targetPlayerId];
  if (!targetPlayer) return 'INVALID_MOVE';
  
  const product = targetPlayer.personalMarket.find(p => p.id === productId);
  if (!product) return 'INVALID_MOVE';
  
  player.prestige -= 1;
  player.actionPoints -= 1;
  
  if (isPositive) {
    product.popularity = Math.min(6, product.popularity + 1);
  } else {
    product.popularity = Math.max(1, product.popularity - 1);
  }
}

function research(G: GameState, ctx: Ctx) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  
  player.actionPoints -= 1;
  
  const dice = rollMultipleDice(3);
  const sum = dice.reduce((a, b) => a + b, 0);
  
  const trendEffect = getTrendEffect(sum);
  
  // „Éó„É¨„Ç§„É§„Éº„Å´„Éà„É¨„É≥„ÉâÊÉÖÂ†±„ÇíÊèê‰æõ
  if (!G.availableTrends) {
    G.availableTrends = {};
  }
  
  G.availableTrends[ctx.currentPlayer] = {
    sum,
    effect: trendEffect,
    playerId: ctx.currentPlayer
  };
  
  // „É≠„Ç∞Ë®òÈå≤
  if (G.playLog) {
    G.playLog.push({
      id: `log-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      round: G.round,
      phase: ctx.phase || G.phase,
      actor: ctx.currentPlayer,
      action: '„É™„Çµ„Éº„ÉÅ',
      details: `„Éà„É¨„É≥„ÉâË™øÊüª: ${trendEffect.name}`,
      timestamp: Date.now()
    });
  }
}

function partTimeWork(G: GameState, ctx: Ctx) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  player.money += 5;
  player.actionPoints -= 2;
}

function buyBack(G: GameState, ctx: Ctx, productId: string) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  
  const productIndex = player.personalMarket.findIndex(p => p.id === productId);
  if (productIndex === -1) return 'INVALID_MOVE';
  
  player.personalMarket.splice(productIndex, 1);
  player.actionPoints -= 1;
}

function discontinue(G: GameState, ctx: Ctx, designId: string) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
  
  const designIndex = player.designs.findIndex(d => d.id === designId);
  if (designIndex === -1) return 'INVALID_MOVE';
  
  player.designs.splice(designIndex, 1);
  player.actionPoints -= 1;
}

function resale(G: GameState, ctx: Ctx, targetPlayerId: string, productId: string, resalePrice: number) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
  if (player.prestige < 1) return 'INVALID_MOVE';
  
  const targetPlayer = G.players[targetPlayerId];
  if (!targetPlayer) return 'INVALID_MOVE';
  
  const productIndex = targetPlayer.personalMarket.findIndex(p => p.id === productId);
  if (productIndex === -1) return 'INVALID_MOVE';
  
  const product = targetPlayer.personalMarket[productIndex];
  if (player.money < product.price) return 'INVALID_MOVE';
  
  const resaleBonus = getResaleBonus(player.resaleHistory);
  const maxResalePrice = Math.min(24, product.price + resaleBonus);
  
  if (resalePrice > maxResalePrice) return 'INVALID_MOVE';
  
  player.money -= product.price;
  targetPlayer.money += product.price;
  player.actionPoints -= 2;
  player.prestige -= 1;
  player.resaleHistory += 1;
  
  targetPlayer.personalMarket.splice(productIndex, 1);
  
  const resaleProduct: Product = {
    ...product,
    id: `resale-${ctx.currentPlayer}-${Date.now()}`,
    price: resalePrice,
    isResale: true,
    originalCost: product.cost,
    originalPlayerId: product.playerId,
    playerId: ctx.currentPlayer
  };
  
  player.personalMarket.push(resaleProduct);
  G.marketPollution++;
}

function getResaleBonus(resaleHistory: number): number {
  if (resaleHistory <= 1) return 5;
  if (resaleHistory <= 4) return 8;
  if (resaleHistory <= 7) return 11;
  return 15;
}

function design(G: GameState, ctx: Ctx, isOpenSource: boolean = false) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
  if (player.designs.length >= 6) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  const designDice = rollMultipleDice(3);
  const selectedCost = designDice[Math.floor(Math.random() * 3)];
  
  const newDesign: Design = {
    id: `design-${ctx.currentPlayer}-${Date.now()}`,
    cost: selectedCost,
    isOpenSource
  };
  
  player.designs.push(newDesign);
  player.actionPoints -= 2;
  
  if (isOpenSource) {
    player.prestige += 2;
  }
}

function promoteRegulation(G: GameState, ctx: Ctx) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
  
  const regulationDice = rollDice() + rollDice();
  if (regulationDice >= 9) {
    G.regulationLevel++;
    
    if (G.regulationLevel >= 3) {
      for (const playerId in G.players) {
        const p = G.players[playerId];
        p.personalMarket = p.personalMarket.filter(product => !product.isResale);
        p.money -= p.resaleHistory * 2;
      }
      
      G.automata.market = G.automata.market.filter(product => !product.isResale);
    }
  }
  
  player.actionPoints -= 2;
}

function dayLabor(G: GameState, ctx: Ctx) {
  const player = G.players[ctx.currentPlayer];
  if (!player || player.actionPoints < 3) return 'INVALID_MOVE';
  if (player.money > 100) return 'INVALID_MOVE';
  
  // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
  if (ctx.phase !== 'action') return 'INVALID_MOVE';
  
  player.money += 18;
  player.actionPoints -= 3;
}

function activateTrend(G: GameState, ctx: Ctx) {
  const player = G.players[ctx.currentPlayer];
  if (!player) {
    console.error('ActivateTrend: Player not found');
    return 'INVALID_MOVE';
  }
  if (!G.availableTrends || !G.availableTrends[ctx.currentPlayer]) {
    console.error('ActivateTrend: No available trend for player');
    return 'INVALID_MOVE';
  }
  
  const trendData = G.availableTrends[ctx.currentPlayer];
  const effect = trendData.effect;
  
  // „Ç≥„Çπ„Éà„ÉÅ„Çß„ÉÉ„ÇØ
  if (effect.cost && effect.cost.prestige && player.prestige < effect.cost.prestige) {
    console.error('ActivateTrend: Insufficient prestige');
    return 'INVALID_MOVE';
  }
  
  // „Ç≥„Çπ„ÉàÊîØÊâï„ÅÑ
  if (effect.cost && effect.cost.prestige) {
    player.prestige -= effect.cost.prestige;
  }
  
  // ÂäπÊûúÂÆüË°å
  executeTrendEffect(G, effect, ctx.currentPlayer);
  
  // „Éà„É¨„É≥„Éâ„ÇíÊ∂àË≤ª
  delete G.availableTrends[ctx.currentPlayer];
  
  // „É≠„Ç∞Ë®òÈå≤
  if (G.playLog) {
    G.playLog.push({
      id: `log-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      round: G.round,
      phase: ctx.phase || G.phase,
      actor: ctx.currentPlayer,
      action: '„Éà„É¨„É≥„ÉâÁô∫Âãï',
      details: `${effect.name}„ÇíÁô∫Âãï`,
      timestamp: Date.now()
    });
  }
}

function getTrendEffect(sum: number) {
  const effects: { [key: number]: { name: string; description: string; cost: { prestige?: number } | null } } = {
    3: { name: 'ÁµåÊ∏àÁâπÈúÄ', description: 'ÂÖ®„Éó„É¨„Ç§„É§„Éº„Å´+15Ë≥áÈáë', cost: null },
    4: { name: 'ÊäÄË°ìÈù©Êñ∞', description: 'Ëá™Ë∫´„ÅÆ‰ªªÊÑè„ÅÆË®≠Ë®à1„Å§„ÅÆ„ÉÄ„Ç§„ÇπÂÄ§-1', cost: null },
    5: { name: '„Ç§„É≥„Éï„É´„Ç®„É≥„Çµ„ÉºÁ¥π‰ªã', description: 'Ëá™Ë∫´„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    6: { name: 'Ê±öÊüìÊîπÂñÑ„Ç≠„É£„É≥„Éö„Éº„É≥', description: 'Â∏ÇÂ†¥Ê±öÊüì„É¨„Éô„É´„Çí-2', cost: null },
    7: { name: '„Çµ„Çπ„ÉÜ„Éä„Éì„É™„ÉÜ„Ç£', description: '‰ªªÊÑè„ÅÆÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+3Ôºà‰ªªÊÑè„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºâ', cost: { prestige: 1 } },
    8: { name: 'DIY„Éñ„Éº„É†', description: 'ÂÖ®„Å¶„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆÊúÄÊñ∞Ë®≠Ë®à„ÅÆ„ÉÄ„Ç§„ÇπÂÄ§-1', cost: null },
    9: { name: '„Ç§„É≥„Éï„É¨ÈÄ≤Ë°å', description: 'ÂÖ®„Å¶„ÅÆËª¢Â£≤„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ‰æ°Ê†º+2ÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    10: { name: '„Ç∑„Éß„Éº„ÉàÂãïÁîª„Éñ„Éº„É†', description: 'Ëª¢Â£≤„ÅåÊàêÂäü„Åô„Çã„Åü„Å≥„Å´+2Ë≥áÈáë„Éú„Éº„Éä„ÇπÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    11: { name: '„Ç∑„Éß„Éº„ÉàÂãïÁîª„Éñ„Éº„É†', description: 'Ëª¢Â£≤„ÅåÊàêÂäü„Åô„Çã„Åü„Å≥„Å´+2Ë≥áÈáë„Éú„Éº„Éä„ÇπÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    12: { name: '„ÉÜ„É¨„ÉØ„Éº„ÇØÈúÄË¶Å', description: '‰æ°Ê†º10‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    13: { name: '„ÇÆ„Éï„ÉàÈúÄË¶Å', description: '‰∫∫Ê∞óÂ∫¶3‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    14: { name: 'Á∑ëÂåñ‰øÉÈÄ≤', description: 'Â∏ÇÂ†¥Ê±öÊüì„É¨„Éô„É´„Çí-3', cost: { prestige: 3 } },
    15: { name: 'Ê∂àË≤ªËÄÖ‰∏ç‰ø°', description: '„ÅÇ„Å™„Åü‰ª•Â§ñ„ÅÆÂÖ®„Éó„É¨„Ç§„É§„Éº„ÅÆÂ®ÅÂé≥-1', cost: { prestige: 2 } },
    16: { name: 'Â∏ÇÂ†¥ÈñãÊîæ', description: '„ÉÄ„Ç§„Çπ„Çí3„Å§Âºï„Åç„ÄÅ„Ç≥„Çπ„Éà0„ÅßË®≠Ë®àÔºà„Ç™„Éº„Éó„É≥„ÇΩ„Éº„Çπ‰∏çÂèØÔºâ„ÄÅË£ΩÈÄ†„ÄÅË≤©Â£≤„ÇíË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„ÄÇ‰ΩøÁî®„Åó„Å™„Åã„Å£„Åü„ÉÄ„Ç§„Çπ„ÅØ„ÉÄ„Ç§„Çπ„Éó„Éº„É´„Å´Êàª„Åô„ÄÇ', cost: null },
    17: { name: 'È¢®Ë©ïÊìç‰Ωú', description: '‰ªªÊÑè„ÅÆ„Éó„É¨„Ç§„É§„Éº1‰∫∫„ÅÆÂ®ÅÂé≥-3', cost: { prestige: 2 } },
    18: { name: 'Â∏ÇÂ†¥„ÅÆÂØµÂÖê', description: '„ÅÇ„Å™„Åü„ÅÆÂ®ÅÂé≥+5', cost: null }
  };
  
  return effects[sum] || { name: 'ÁÑ°ÂäπÊûú', description: 'Áâπ„Å´Â§âÂåñ„Å™„Åó', cost: null };
}

function executeTrendEffect(G: GameState, effect: any, playerId: string) {
  console.log(`üåü Executing trend effect: ${effect.name}`);
  
  switch (effect.name) {
    case 'ÁµåÊ∏àÁâπÈúÄ':
      for (const pid in G.players) {
        G.players[pid].money += 15;
      }
      console.log('üìà All players gained 15 money');
      break;
      
    case '„Ç§„É≥„Éï„É´„Ç®„É≥„Çµ„ÉºÁ¥π‰ªã':
      const player = G.players[playerId];
      if (player) {
        for (const product of player.personalMarket) {
          // ‰∫∫Ê∞óÂ∫¶‰∏äÊòáÊôÇ„ÅÆ‰ΩçÁΩÆÊõ¥Êñ∞Âá¶ÁêÜ
          const oldPopularity = product.popularity;
          product.popularity = Math.min(6, product.popularity + 1);
          
          // „Éë„Éº„ÇΩ„Éä„É´„Éª„Éû„Éº„Ç±„ÉÉ„ÉàÂÜÖ„Åß„ÅÆ‰ΩçÁΩÆË™øÊï¥„ÅåÂøÖË¶Å„Å™Â†¥Âêà
          if (product.popularity !== oldPopularity && product.price > 0) {
            // ÂïÜÂìÅ„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞Ôºà‰æ°Ê†º„ÅØÂ§â„Çè„Çâ„Åö„ÄÅ‰∫∫Ê∞óÂ∫¶„ÅÆ„ÅøÂ§âÊõ¥Ôºâ
            console.log(`Product ${product.id} popularity: ${oldPopularity} ‚Üí ${product.popularity}`);
          }
        }
        console.log(`üì± All products of player ${playerId} gained +1 popularity`);
      }
      break;
      
    case 'Ê±öÊüìÊîπÂñÑ„Ç≠„É£„É≥„Éö„Éº„É≥':
      G.marketPollution = Math.max(0, G.marketPollution - 2);
      console.log(`üå± Market pollution reduced by 2, now: ${G.marketPollution}`);
      break;
      
    case '„ÉÜ„É¨„ÉØ„Éº„ÇØÈúÄË¶Å':
      // ‰æ°Ê†º10‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶+1
      for (const pid in G.players) {
        for (const product of G.players[pid].personalMarket) {
          if (product.price > 0 && product.price <= 10) {
            const oldPopularity = product.popularity;
            product.popularity = Math.min(6, product.popularity + 1);
            if (product.popularity !== oldPopularity) {
              console.log(`Product ${product.id} popularity: ${oldPopularity} ‚Üí ${product.popularity}`);
            }
          }
        }
      }
      for (const product of G.automata.market) {
        if (product.price > 0 && product.price <= 10) {
          product.popularity = Math.min(6, product.popularity + 1);
        }
      }
      console.log('üíª All products with price ‚â§10 gained +1 popularity');
      break;
      
    case '„Ç§„É≥„Éï„É¨ÈÄ≤Ë°å':
      // ÂÖ®„Å¶„ÅÆËª¢Â£≤„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ‰æ°Ê†º+2ÔºàÊ∞∏Á∂öÔºâ
      for (const pid in G.players) {
        for (const product of G.players[pid].personalMarket) {
          if (!product.isResale && product.price > 0) {
            product.price += 2;
          }
        }
      }
      for (const product of G.automata.market) {
        if (!product.isResale && product.price > 0) {
          product.price += 2;
        }
      }
      console.log('üí∞ All non-resale products gained +2 price');
      break;
      
    case '„Çµ„Çπ„ÉÜ„Éä„Éì„É™„ÉÜ„Ç£':
      // „Éó„É¨„Ç§„É§„Éº„Åå‰ªªÊÑè„ÅÆÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+3„Åß„Åç„ÇãÔºàÂÆüË£Ö„ÅØÁ∞°ÊòìÁâàÔºöËá™ÂàÜ„ÅÆÂïÜÂìÅÂÖ®„Å¶„Å´+1Ôºâ
      const sustainabilityPlayer = G.players[playerId];
      if (sustainabilityPlayer) {
        for (const product of sustainabilityPlayer.personalMarket) {
          const oldPopularity = product.popularity;
          product.popularity = Math.min(6, product.popularity + 1);
          if (product.popularity !== oldPopularity) {
            console.log(`Product ${product.id} popularity: ${oldPopularity} ‚Üí ${product.popularity}`);
          }
        }
      }
      break;
      
    default:
      console.log(`Unknown trend effect: ${effect.name}`);
      break;
  }
}

export default MarketDisruption;