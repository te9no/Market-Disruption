const { Server, Origins } = require('boardgame.io/server');

// „Éó„É≠„Çª„ÇπÁµÇ‰∫ÜÊôÇ„ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞
process.on('SIGTERM', () => {
  console.log('üì° Received SIGTERM, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üì° Received SIGINT, shutting down gracefully...');
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  console.error('üí• Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// „Éò„É´„Éë„ÉºÈñ¢Êï∞
const rollDice = (sides = 6) => Math.floor(Math.random() * sides) + 1;
const rollMultipleDice = (count, sides = 6) => Array.from({ length: count }, () => rollDice(sides));

const getDemandValue = (cost) => {
  const demandMap = {
    1: [6, 7, 8],
    2: [5, 9], 
    3: [4, 10],
    4: [3, 11],
    5: [2, 12]
  };
  return demandMap[cost] || [];
};

const checkVictoryConditions = (player) => {
  return (player.prestige >= 17 && player.money >= 75) || player.money >= 150;
};

const getMaxPrice = (cost, prestige) => {
  if (prestige >= 9) return cost * 4;
  if (prestige >= 3) return cost * 3;
  return cost * 2;
};

const getResaleBonus = (resaleHistory) => {
  if (resaleHistory <= 1) return 5;
  if (resaleHistory <= 4) return 8;
  if (resaleHistory <= 7) return 11;
  return 15;
};

// „É≠„Ç∞Ë®òÈå≤„Éò„É´„Éë„ÉºÈñ¢Êï∞
const addToPlayLog = (G, ctx, actor, action, details) => {
  if (!G.playLog) G.playLog = [];
  G.playLog.push({
    id: `log-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    round: G.round,
    phase: ctx?.phase || G.phase,
    actor,
    action,
    details,
    timestamp: Date.now()
  });
};

// Initial game state functions
const initialGameState = {
  players: {},
  currentPlayer: '0',
  phase: 'action',
  round: 1,
  marketPollution: 0,
  regulationLevel: 0,
  automata: {
    manufacturerMoney: Infinity,
    resaleOrganizationMoney: 20,
    market: []
  },
  trendEffects: [],
  playLog: [],
  gameEnded: false,
  winner: null
};

const createInitialPlayer = (id, name) => ({
  id,
  name,
  money: 30,
  prestige: 5,
  resaleHistory: 0,
  actionPoints: 3,
  designs: [],
  personalMarket: []
});

// Êú¨Ê†ºÁöÑ„Å™„Ç≤„Éº„É†ÂÆöÁæ©
const MarketDisruption = {
  name: 'MarketDisruption',
  setup: ({ ctx }) => {
    const G = { ...initialGameState };
    
    // „Éó„É¨„Ç§„É§„ÉºÂàùÊúüÂåñ
    for (let i = 0; i < ctx.numPlayers; i++) {
      const playerId = String(i);
      G.players[playerId] = createInitialPlayer(playerId, `Player ${i + 1}`);
      
      // Ë®≠Ë®àÂõ≥„Çí„É©„É≥„ÉÄ„É†„Å´ÁîüÊàêÔºàTypeScriptÁâà„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
      const designDice = rollMultipleDice(2);
      G.players[playerId].designs = designDice.map((cost, index) => ({
        id: `design-${playerId}-${index}`,
        cost,
        isOpenSource: false
      }));
    }
    
    return G;
  },
  
  moves: {
    manufacture: ({ G, ctx }, designId) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) {
        console.error('Manufacture: Player not found or insufficient AP');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøË£ΩÈÄ†ÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('Manufacture: Not in action phase');
        return;
      }
      
      const design = player.designs.find(d => d.id === designId);
      if (!design || player.money < design.cost) {
        console.error('Manufacture: Design not found or insufficient money', { designId, playerMoney: player.money, designCost: design?.cost });
        return;
      }
      
      player.money -= design.cost;
      player.actionPoints -= 1;
      
      const product = {
        id: `product-${ctx.currentPlayer}-${Date.now()}`,
        cost: design.cost,
        price: 0,
        popularity: 1,
        playerId: ctx.currentPlayer,
        isResale: false
      };
      
      player.personalMarket.push(product);
      console.log(`Manufacture: Successfully created product ${product.id} with cost ${design.cost}`);
      
      addToPlayLog(G, ctx, ctx.currentPlayer, 'Ë£ΩÈÄ†', `„Ç≥„Çπ„Éà${design.cost}„ÅÆÂïÜÂìÅ„ÇíË£ΩÈÄ†`);
    },
    
    sell: ({ G, ctx }, productId, price) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) {
        console.error('Sell: Player not found or insufficient AP');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøË≤©Â£≤ÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('Sell: Not in action phase');
        return;
      }
      
      if (!productId || typeof price !== 'number' || price <= 0 || !Number.isInteger(price)) {
        console.error('Sell: Invalid parameters', { productId, price, priceType: typeof price });
        return;
      }
      
      const product = player.personalMarket.find(p => p.id === productId && p.price === 0);
      if (!product) {
        console.error('Sell: Product not found or already priced', { 
          productId, 
          personalMarket: player.personalMarket.map(p => ({ id: p.id, price: p.price }))
        });
        return;
      }
      
      product.price = price;
      player.actionPoints -= 1;
      console.log(`Sell: Successfully set price ${price} for product ${productId}`);
      
      addToPlayLog(G, ctx, ctx.currentPlayer, 'Ë≤©Â£≤Ë®≠ÂÆö', `ÂïÜÂìÅ„Çí${price}Ë≥áÈáë„ÅßË≤©Â£≤Ë®≠ÂÆö`);
    },
    
    purchase: ({ G, ctx }, targetPlayerId, productId) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
      
      if (ctx.phase !== 'action') return 'INVALID_MOVE';
      
      // „Ç™„Éº„Éà„Éû„Åã„Çâ„ÅÆË≥ºÂÖ•„ÅÆÂ†¥Âêà
      if (targetPlayerId === 'automata') {
        const productIndex = G.automata.market.findIndex(p => p.id === productId);
        if (productIndex === -1) return 'INVALID_MOVE';
        
        const product = G.automata.market[productIndex];
        if (player.money < product.price) return 'INVALID_MOVE';
        
        player.money -= product.price;
        player.actionPoints -= 1;
        
        G.automata.market.splice(productIndex, 1);
        return;
      }
      
      // „Éó„É¨„Ç§„É§„Éº„Åã„Çâ„ÅÆË≥ºÂÖ•„ÅÆÂ†¥Âêà
      const targetPlayer = G.players[targetPlayerId];
      if (!targetPlayer) return 'INVALID_MOVE';
      
      const productIndex = targetPlayer.personalMarket.findIndex(p => p.id === productId);
      if (productIndex === -1) return 'INVALID_MOVE';
      
      const product = targetPlayer.personalMarket[productIndex];
      if (player.money < product.price) return 'INVALID_MOVE';
      
      player.money -= product.price;
      targetPlayer.money += product.price;
      player.actionPoints -= 1;
      
      targetPlayer.personalMarket.splice(productIndex, 1);
    },
    
    partTimeWork: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 2) {
        console.error('PartTimeWork: Player not found or insufficient AP');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('PartTimeWork: Not in action phase');
        return;
      }
      
      player.money += 5;
      player.actionPoints -= 2;
      console.log(`PartTimeWork: Player ${ctx.currentPlayer} earned 5 money`);
      
      addToPlayLog(G, ctx, ctx.currentPlayer, '„Ç¢„É´„Éê„Ç§„Éà', '5Ë≥áÈáë„ÇíÁç≤Âæó');
    },
    
    design: ({ G, ctx }, isOpenSource = false) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 2) {
        console.error('Design: Player not found or insufficient AP');
        return;
      }
      if (player.designs.length >= 6) {
        console.error('Design: Too many designs');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('Design: Not in action phase');
        return;
      }
      
      const designDice = rollMultipleDice(3);
      const selectedCost = designDice[Math.floor(Math.random() * 3)];
      
      const newDesign = {
        id: `design-${ctx.currentPlayer}-${Date.now()}`,
        cost: selectedCost,
        isOpenSource
      };
      
      player.designs.push(newDesign);
      player.actionPoints -= 2;
      
      if (isOpenSource) {
        player.prestige += 2;
        console.log(`Design: Player ${ctx.currentPlayer} created open-source design with cost ${selectedCost}, gained 2 prestige`);
        addToPlayLog(G, ctx, ctx.currentPlayer, '„Ç™„Éº„Éó„É≥„ÇΩ„Éº„ÇπË®≠Ë®à', `„Ç≥„Çπ„Éà${selectedCost}„ÅÆË®≠Ë®à„Çí‰ΩúÊàê„ÄÅÂ®ÅÂé≥+2`);
      } else {
        console.log(`Design: Player ${ctx.currentPlayer} created design with cost ${selectedCost}`);
        addToPlayLog(G, ctx, ctx.currentPlayer, 'Ë®≠Ë®à', `„Ç≥„Çπ„Éà${selectedCost}„ÅÆË®≠Ë®à„Çí‰ΩúÊàê`);
      }
    },
    
    dayLabor: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 3) {
        console.error('DayLabor: Player not found or insufficient AP');
        return;
      }
      if (player.money > 100) {
        console.error('DayLabor: Player has too much money');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('DayLabor: Not in action phase');
        return;
      }
      
      player.money += 18;
      player.actionPoints -= 3;
      console.log(`DayLabor: Player ${ctx.currentPlayer} earned 18 money`);
      
      addToPlayLog(G, ctx, ctx.currentPlayer, 'Êó•Èõá„ÅÑÂä¥ÂÉç', '18Ë≥áÈáë„ÇíÁç≤Âæó');
    },
    
    review: ({ G, ctx }, targetPlayerId, productId, isPositive) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
      if (player.prestige < 1) return 'INVALID_MOVE';
      
      const targetPlayer = G.players[targetPlayerId];
      if (!targetPlayer) return 'INVALID_MOVE';
      
      const product = targetPlayer.personalMarket.find(p => p.id === productId);
      if (!product) return 'INVALID_MOVE';
      
      player.prestige -= 1;
      player.actionPoints -= 1;
      
      if (isPositive) {
        product.popularity = Math.min(6, product.popularity + 1);
      } else {
        product.popularity = Math.max(1, product.popularity - 1);
      }
    },
    
    research: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) {
        console.error('Research: Player not found or insufficient AP');
        return;
      }
      
      // action„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„ÅøÂÆüË°åÂèØËÉΩ
      if (ctx.phase !== 'action') {
        console.error('Research: Not in action phase');
        return;
      }
      
      player.actionPoints -= 1;
      
      // „Éà„É¨„É≥„Éâ„ÉÄ„Ç§„Çπ3ÂÄã„ÇíÊåØ„Çã
      const trendDice = rollMultipleDice(3);
      const trendSum = trendDice.reduce((sum, die) => sum + die, 0);
      
      // „Éà„É¨„É≥„Éâ„Éê„Ç∫„ÉÜ„Éº„Éñ„É´„Å´Âü∫„Å•„ÅèÂäπÊûú„ÇíÊèê‰æõ
      const trendEffects = getTrendEffect(trendSum);
      
      console.log(`üî¨ Research: Player ${ctx.currentPlayer} rolled trend dice ${trendDice.join(',')} (sum: ${trendSum})`);
      console.log(`üìä Trend Effect: ${trendEffects.name} - ${trendEffects.description}`);
      
      // Á†îÁ©∂ÁµêÊûú„Çí„Ç≤„Éº„É†Áä∂ÊÖã„Å´‰øùÂ≠òÔºà„Éó„É¨„Ç§„É§„Éº„ÅåÂäπÊûúÁô∫Âãï„ÇíÈÅ∏Êäû„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ
      if (!G.availableTrends) G.availableTrends = {};
      G.availableTrends[ctx.currentPlayer] = {
        sum: trendSum,
        effect: trendEffects,
        playerId: ctx.currentPlayer
      };
      
      addToPlayLog(G, ctx, ctx.currentPlayer, '„É™„Çµ„Éº„ÉÅ', `„Éà„É¨„É≥„ÉâË™øÊüª: ${trendEffects.name}`);
    },

    activateTrend: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      if (!player) {
        console.error('ActivateTrend: Player not found');
        return;
      }

      if (!G.availableTrends || !G.availableTrends[ctx.currentPlayer]) {
        console.error('ActivateTrend: No available trend for player');
        return;
      }

      const trendData = G.availableTrends[ctx.currentPlayer];
      const effect = trendData.effect;

      // „Ç≥„Çπ„Éà„ÉÅ„Çß„ÉÉ„ÇØ
      if (effect.cost && effect.cost.prestige && player.prestige < effect.cost.prestige) {
        console.error('ActivateTrend: Insufficient prestige');
        return;
      }

      // „Ç≥„Çπ„ÉàÊîØÊâï„ÅÑ
      if (effect.cost && effect.cost.prestige) {
        player.prestige -= effect.cost.prestige;
      }

      // ÂäπÊûúÂÆüË°å
      executeTrendEffect(G, effect, ctx.currentPlayer);

      // „Éà„É¨„É≥„Éâ„ÇíÊ∂àË≤ª
      delete G.availableTrends[ctx.currentPlayer];

      addToPlayLog(G, ctx, ctx.currentPlayer, '„Éà„É¨„É≥„ÉâÁô∫Âãï', `${effect.name}„ÇíÁô∫Âãï`);
    },
    
    buyBack: ({ G, ctx }, productId) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
      
      const productIndex = player.personalMarket.findIndex(p => p.id === productId);
      if (productIndex === -1) return 'INVALID_MOVE';
      
      player.personalMarket.splice(productIndex, 1);
      player.actionPoints -= 1;
    },
    
    discontinue: ({ G, ctx }, designId) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 1) return 'INVALID_MOVE';
      
      const designIndex = player.designs.findIndex(d => d.id === designId);
      if (designIndex === -1) return 'INVALID_MOVE';
      
      player.designs.splice(designIndex, 1);
      player.actionPoints -= 1;
    },
    
    resale: ({ G, ctx }, targetPlayerId, productId, resalePrice) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
      if (player.prestige < 1) return 'INVALID_MOVE';
      
      const targetPlayer = G.players[targetPlayerId];
      if (!targetPlayer) return 'INVALID_MOVE';
      
      const productIndex = targetPlayer.personalMarket.findIndex(p => p.id === productId);
      if (productIndex === -1) return 'INVALID_MOVE';
      
      const product = targetPlayer.personalMarket[productIndex];
      if (player.money < product.price) return 'INVALID_MOVE';
      
      const resaleBonus = getResaleBonus(player.resaleHistory);
      const maxResalePrice = Math.min(24, product.price + resaleBonus);
      
      if (resalePrice > maxResalePrice) return 'INVALID_MOVE';
      
      player.money -= product.price;
      targetPlayer.money += product.price;
      player.actionPoints -= 2;
      player.prestige -= 1;
      player.resaleHistory += 1;
      
      targetPlayer.personalMarket.splice(productIndex, 1);
      
      const resaleProduct = {
        ...product,
        id: `resale-${ctx.currentPlayer}-${Date.now()}`,
        price: resalePrice,
        isResale: true,
        originalCost: product.cost,
        originalPlayerId: product.playerId,
        playerId: ctx.currentPlayer
      };
      
      player.personalMarket.push(resaleProduct);
      G.marketPollution++;
    },
    
    promoteRegulation: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      if (!player || player.actionPoints < 2) return 'INVALID_MOVE';
      
      const regulationDice = rollDice() + rollDice();
      if (regulationDice >= 9) {
        G.regulationLevel++;
        
        if (G.regulationLevel >= 3) {
          for (const playerId in G.players) {
            const p = G.players[playerId];
            p.personalMarket = p.personalMarket.filter(product => !product.isResale);
            p.money -= p.resaleHistory * 2;
          }
          
          G.automata.market = G.automata.market.filter(product => !product.isResale);
        }
      }
      
      player.actionPoints -= 2;
    }
  },
  
  minPlayers: 1,
  maxPlayers: 4,
  
  phases: {
    action: {
      start: true,
      next: 'automata',
      turn: {
        order: {
          first: () => 0,
          next: ({ ctx }) => {
            if (ctx.numPlayers === 1) {
              return 0; // 1‰∫∫„Éó„É¨„Ç§„ÅÆÂ†¥Âêà„ÅØÂ∏∏„Å´Âêå„Åò„Éó„É¨„Ç§„É§„Éº
            }
            return (ctx.playOrderPos + 1) % ctx.numPlayers;
          },
        }
      },
      // „Éï„Çß„Éº„Ç∫ÁµÇ‰∫Ü„ÅØÊâãÂãï„ÅßÂà∂Âæ°Ôºà„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØÊôÇÔºâ
      endIf: () => false,
      onEnd: ({ G }) => {
        console.log('Action phase ending - resetting AP for all players');
        for (const playerId in G.players) {
          G.players[playerId].actionPoints = 3;
        }
      }
    },
    
    automata: {
      moves: {},
      onBegin: ({ G }) => {
        console.log('ü§ñ Automata phase started: executing automata actions');
        executeManufacturerAutomata(G);
        executeResaleAutomata(G);
        console.log('‚úÖ Automata actions completed');
      },
      // automata„Éï„Çß„Éº„Ç∫„ÅØÂç≥Â∫ß„Å´ÁµÇ‰∫Ü„Åô„Çã
      endIf: () => true,
      next: 'market'
    },
    
    market: {
      moves: {},
      onBegin: ({ G }) => {
        console.log('üè™ Market phase started: executing market actions');
        executeMarketPhase(G);
        console.log('‚úÖ Market actions completed');
      },
      // market„Éï„Çß„Éº„Ç∫„ÇÇÂç≥Â∫ß„Å´ÁµÇ‰∫Ü„Åô„Çã
      endIf: () => true,
      next: 'action',
      onEnd: ({ G }) => {
        G.round++;
        console.log(`üéÆ Starting round ${G.round}`);
        
        // ÂãùÂà©Êù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ
        for (const playerId in G.players) {
          if (checkVictoryConditions(G.players[playerId])) {
            G.gameEnded = true;
            G.winner = playerId;
            G.phase = 'victory';
            console.log(`üèÜ Game ended! Winner: ${G.players[playerId].name}`);
            break;
          }
        }
      }
    },

    victory: {
      moves: {},
      turn: {
        order: {
          first: () => 0,
          next: () => undefined,
        }
      }
    }
  },
  
  endIf: ({ G }) => {
    if (G.gameEnded) {
      return { winner: G.winner };
    }
  },
  
  turn: {
    order: {
      first: () => 0,
      next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.numPlayers,
    }
  },
  
  // „Éï„Çß„Éº„Ç∫ÁµÇ‰∫ÜÁî®„ÅÆ„Ç§„Éô„É≥„Éà
  events: {
    endPhase: true,
    endTurn: true
  }
};

// „Ç™„Éº„Éà„ÉûÂÆüË°åÈñ¢Êï∞
function executeManufacturerAutomata(G) {
  const diceSum = rollDice() + rollDice();
  
  let action;
  let targetCost;
  let priceMultiplier;
  
  if (diceSum <= 4) {
    action = 'high-cost';
    // „ÉÄ„Ç§„Çπ„ÇíÂºï„ÅÑ„Å¶„Ç≥„Çπ„Éà3-5„Å´„Å™„Çã„Åæ„Åß„É≠„Éº„É´
    do { targetCost = rollDice(); } while (targetCost < 3);
    priceMultiplier = 3;
  } else if (diceSum <= 7) {
    action = 'mid-cost';
    // „ÉÄ„Ç§„Çπ„ÇíÂºï„ÅÑ„Å¶„Ç≥„Çπ„Éà3„Å´„Åô„Çã
    targetCost = 3;
    priceMultiplier = 2;
  } else if (diceSum <= 10) {
    action = 'low-cost';
    // „ÉÄ„Ç§„Çπ„ÇíÂºï„ÅÑ„Å¶„Ç≥„Çπ„Éà1-3„Å´„Å™„Çã„Åæ„Åß„É≠„Éº„É´
    do { targetCost = rollDice(); } while (targetCost > 3);
    priceMultiplier = 2;
  } else {
    action = 'clearance';
    // Âú®Â∫´‰∏ÄÊéÉË≤©Â£≤ - Êó¢Â≠òÂïÜÂìÅ„ÅÆ‰æ°Ê†º„Çí‰∏ã„Åí„Çã
    for (const product of G.automata.market) {
      product.price = Math.max(1, product.price - 2);
    }
    console.log(`ü§ñ Manufacturer Automata: dice=${diceSum}, action=clearance`);
    console.log(`üì¶ Clearance: reduced prices of ${G.automata.market.length} products`);
    return;
  }
  
  console.log(`ü§ñ Manufacturer Automata: dice=${diceSum}, action=${action}`);
  
  // Ë£ΩÈÄ†„Ç¢„ÇØ„Ç∑„Éß„É≥
  const product = {
    id: `manufacturer-automata-${Date.now()}`,
    cost: targetCost,
    price: targetCost * priceMultiplier,
    popularity: 1,
    playerId: 'manufacturer-automata',
    isResale: false
  };
  
  G.automata.market.push(product);
  console.log(`üè≠ Manufacturer created product: cost=${targetCost}, price=${product.price}`);
  
  addToPlayLog(G, null, 'manufacturer-automata', 'Ë£ΩÈÄ†', `„Ç≥„Çπ„Éà${targetCost}„ÄÅ‰æ°Ê†º${product.price}„ÅÆÂïÜÂìÅ„ÇíË£ΩÈÄ†`);
  
  // ÂâØË°åÂãïÔºà„É¨„Éì„É•„ÉºÔºâ
  if (action === 'high-cost') {
    // Â∏ÇÂ†¥ÊúÄÈ´ò‰æ°Ê†ºÂïÜÂìÅ„Å´‰ΩéË©ï‰æ°„É¨„Éì„É•„Éº
    const allProducts = [];
    for (const playerId in G.players) {
      allProducts.push(...G.players[playerId].personalMarket);
    }
    allProducts.push(...G.automata.market.filter(p => p.id !== product.id)); // Ëá™ÂàÜ„ÅÆÊñ∞ÂïÜÂìÅ„ÅØÈô§Â§ñ
    
    if (allProducts.length > 0) {
      const highestPriceProducts = allProducts
        .filter(p => p.price > 0)
        .sort((a, b) => b.price - a.price);
      
      if (highestPriceProducts.length > 0) {
        const targetProduct = highestPriceProducts[0];
        targetProduct.popularity = Math.max(1, targetProduct.popularity - 1);
        console.log(`üëé Manufacturer gave negative review to product ${targetProduct.id} (price: ${targetProduct.price})`);
        
        addToPlayLog(G, null, 'manufacturer-automata', '„É¨„Éì„É•„Éº', `‰æ°Ê†º${targetProduct.price}„ÅÆÂïÜÂìÅ„Å´‰ΩéË©ï‰æ°`);
      }
    }
  } else if (action === 'low-cost') {
    // Ëá™ÂàÜ„ÅÆÊúÄÂÆâÂïÜÂìÅ„Å´È´òË©ï‰æ°„É¨„Éì„É•„Éº
    const ownProducts = G.automata.market.filter(p => p.price > 0);
    if (ownProducts.length > 0) {
      const cheapestProduct = ownProducts.sort((a, b) => a.price - b.price)[0];
      cheapestProduct.popularity = Math.min(6, cheapestProduct.popularity + 1);
      console.log(`üëç Manufacturer gave positive review to own product ${cheapestProduct.id} (price: ${cheapestProduct.price})`);
      
      addToPlayLog(G, null, 'manufacturer-automata', '„É¨„Éì„É•„Éº', `‰æ°Ê†º${cheapestProduct.price}„ÅÆËá™ÂïÜÂìÅ„Å´È´òË©ï‰æ°`);
    }
  }
}

function executeResaleAutomata(G) {
  // Ë≥áÈáëÁÆ°ÁêÜÔºöÂêÑ„Çø„Éº„É≥ÈñãÂßãÊôÇ„Å´20Ë≥áÈáë„Åæ„ÅßËá™ÂãïË£úÂÖÖ
  if (G.automata.resaleOrganizationMoney < 20) {
    G.automata.resaleOrganizationMoney = 20;
  }
  
  const diceSum = rollDice() + rollDice();
  console.log(`üîÑ Resale Automata: dice=${diceSum}, money=${G.automata.resaleOrganizationMoney}`);
  
  // ÊßòÂ≠êË¶ãÔºà6,7,8Ôºâ
  if (diceSum >= 6 && diceSum <= 8) {
    console.log('üìã Resale Automata: no action (watching market)');
    return;
  }
  
  // ÂÖ®„Éó„É¨„Ç§„É§„Éº„Å®„Ç™„Éº„Éà„Éû„ÅÆ„Éû„Éº„Ç±„ÉÉ„Éà„Åã„ÇâÂïÜÂìÅ„ÇíÂèñÂæó
  const allProducts = [];
  for (const playerId in G.players) {
    for (const product of G.players[playerId].personalMarket) {
      if (product.price > 0) { // ‰æ°Ê†º„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂïÜÂìÅ„ÅÆ„Åø
        allProducts.push({...product, sourcePlayerId: playerId, sourceType: 'player'});
      }
    }
  }
  for (const product of G.automata.market) {
    if (product.price > 0 && !product.isResale) { // Ëª¢Â£≤ÂìÅ„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ„Åø
      allProducts.push({...product, sourcePlayerId: 'automata', sourceType: 'automata'});
    }
  }
  
  let targetProducts = [];
  let resalePrice = 0;
  
  if (diceSum <= 4) {
    // Â§ßÈáèË≤∑„ÅÑÂç†„ÇÅÔºöÊúÄÂÆâÂÄ§ÂïÜÂìÅ„Çí3ÂÄã„Åæ„Åß
    targetProducts = allProducts
      .filter(p => p.price > 0)
      .sort((a, b) => a.price - b.price || b.popularity - a.popularity)
      .slice(0, 3);
    resalePrice = 5; // Ë≥ºÂÖ•‰æ°Ê†º+5Ë≥áÈáë
  } else if (diceSum === 5 || diceSum === 9) {
    // ÈÅ∏Âà•Ë≥ºÂÖ•Ôºö‰∫∫Ê∞óÂ∫¶ÊúÄÈ´ò„ÅÆÂïÜÂìÅ„Çí1ÂÄã
    targetProducts = allProducts
      .filter(p => p.price > 0)
      .sort((a, b) => b.popularity - a.popularity || a.price - b.price)
      .slice(0, 1);
    resalePrice = 5; // Ë≥ºÂÖ•‰æ°Ê†º+5Ë≥áÈáë
  } else if (diceSum >= 10) {
    // ÊäïÊ©üË≥ºÂÖ•Ôºö„É©„É≥„ÉÄ„É†ÂïÜÂìÅ„Çí1ÂÄã
    if (allProducts.length > 0) {
      const randomIndex = Math.floor(Math.random() * allProducts.length);
      targetProducts = [allProducts[randomIndex]];
    }
    resalePrice = 8; // Ë≥ºÂÖ•‰æ°Ê†º+8Ë≥áÈáë
  }
  
  console.log(`üéØ Resale Automata targeting ${targetProducts.length} products`);
  
  for (const product of targetProducts) {
    if (G.automata.resaleOrganizationMoney >= product.price) {
      // Ë≥ºÂÖ•Âá¶ÁêÜ
      G.automata.resaleOrganizationMoney -= product.price;
      
      // Ëª¢Â£≤ÂïÜÂìÅ„Å®„Åó„Å¶Âá∫ÂìÅ
      const resaleProduct = {
        id: `resale-automata-${Date.now()}`,
        cost: product.cost,
        price: product.price + resalePrice,
        popularity: product.popularity,
        playerId: 'resale-automata',
        isResale: true,
        originalCost: product.cost,
        originalPlayerId: product.playerId
      };
      
      G.automata.market.push(resaleProduct);
      
      // ÂÖÉ„ÅÆÂïÜÂìÅ„ÇíÂâäÈô§„Åó„ÄÅÂ£≤‰∏ä„ÇíÂÖÉ„ÅÆÊâÄÊúâËÄÖ„Å´Ê∏°„Åô
      if (product.sourceType === 'player') {
        const originalPlayer = G.players[product.sourcePlayerId];
        if (originalPlayer) {
          originalPlayer.money += product.price;
          const productIndex = originalPlayer.personalMarket.findIndex(p => p.id === product.id);
          if (productIndex !== -1) {
            originalPlayer.personalMarket.splice(productIndex, 1);
          }
        }
      } else {
        // „Ç™„Éº„Éà„Éû„ÅÆÂïÜÂìÅ„ÅÆÂ†¥Âêà„ÄÅ„Éû„Éº„Ç±„ÉÉ„Éà„Åã„ÇâÂâäÈô§
        const productIndex = G.automata.market.findIndex(p => p.id === product.id);
        if (productIndex !== -1) {
          G.automata.market.splice(productIndex, 1);
        }
      }
      
      // Â∏ÇÂ†¥Ê±öÊüì„É¨„Éô„É´Â¢óÂä†
      G.marketPollution++;
      console.log(`üí∞ Resale: bought product for ${product.price}, selling for ${resaleProduct.price}, pollution: ${G.marketPollution}`);
      
      addToPlayLog(G, null, 'resale-automata', 'Ëª¢Â£≤', `${product.price}Ë≥áÈáë„ÅßË≥ºÂÖ•„ÄÅ${resaleProduct.price}Ë≥áÈáë„ÅßËª¢Â£≤`);
    }
  }
}

function executeMarketPhase(G) {
  const demandDice = rollDice() + rollDice();
  console.log(`üé≤ Market phase: demand dice=${demandDice}`);
  
  const allProducts = [];
  for (const playerId in G.players) {
    allProducts.push(...G.players[playerId].personalMarket);
  }
  allProducts.push(...G.automata.market);
  
  const eligibleProducts = allProducts.filter(product => {
    const demandValues = getDemandValue(product.cost);
    return demandValues.includes(demandDice);
  });
  
  console.log(`üìà ${eligibleProducts.length} products eligible for purchase`);
  
  eligibleProducts.sort((a, b) => b.popularity - a.popularity || a.price - b.price);
  
  const purchasedProducts = eligibleProducts.slice(0, 5);
  console.log(`üõí ${purchasedProducts.length} products purchased`);
  
  for (const product of purchasedProducts) {
    const actualPrice = Math.max(1, product.price - getPollutionPenalty(G.marketPollution));
    
    if (product.playerId === 'manufacturer-automata' || product.playerId === 'resale-automata') {
      const productIndex = G.automata.market.findIndex(p => p.id === product.id);
      if (productIndex !== -1) {
        G.automata.market.splice(productIndex, 1);
      }
    } else {
      const player = G.players[product.playerId];
      if (player) {
        player.money += actualPrice;
        const productIndex = player.personalMarket.findIndex(p => p.id === product.id);
        if (productIndex !== -1) {
          player.personalMarket.splice(productIndex, 1);
        }
      }
    }
    
    console.log(`‚úÖ Sold product: ${product.cost}/${product.price} for ${actualPrice} to player ${product.playerId}`);
  }
}

function getPollutionPenalty(pollutionLevel) {
  if (pollutionLevel <= 2) return 0;
  if (pollutionLevel <= 5) return 1;
  if (pollutionLevel <= 8) return 2;
  if (pollutionLevel <= 11) return 3;
  return 4;
}

const getTrendEffect = (sum) => {
  const effects = {
    3: { name: 'ÁµåÊ∏àÁâπÈúÄ', description: 'ÂÖ®„Éó„É¨„Ç§„É§„Éº„Å´+15Ë≥áÈáë', cost: null },
    4: { name: 'ÊäÄË°ìÈù©Êñ∞', description: 'Ëá™Ë∫´„ÅÆ‰ªªÊÑè„ÅÆË®≠Ë®à1„Å§„ÅÆ„ÉÄ„Ç§„ÇπÂÄ§-1', cost: null },
    5: { name: '„Ç§„É≥„Éï„É´„Ç®„É≥„Çµ„ÉºÁ¥π‰ªã', description: 'Ëá™Ë∫´„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    6: { name: 'Ê±öÊüìÊîπÂñÑ„Ç≠„É£„É≥„Éö„Éº„É≥', description: 'Â∏ÇÂ†¥Ê±öÊüì„É¨„Éô„É´„Çí-2', cost: null },
    7: { name: '„Çµ„Çπ„ÉÜ„Éä„Éì„É™„ÉÜ„Ç£', description: '‰ªªÊÑè„ÅÆÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+3Ôºà‰ªªÊÑè„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºâ', cost: { prestige: 1 } },
    8: { name: 'DIY„Éñ„Éº„É†', description: 'ÂÖ®„Å¶„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆÊúÄÊñ∞Ë®≠Ë®à„ÅÆ„ÉÄ„Ç§„ÇπÂÄ§-1', cost: null },
    9: { name: '„Ç§„É≥„Éï„É¨ÈÄ≤Ë°å', description: 'ÂÖ®„Å¶„ÅÆËª¢Â£≤„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ‰æ°Ê†º+2ÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    10: { name: '„Ç∑„Éß„Éº„ÉàÂãïÁîª„Éñ„Éº„É†', description: 'Ëª¢Â£≤„ÅåÊàêÂäü„Åô„Çã„Åü„Å≥„Å´+2Ë≥áÈáë„Éú„Éº„Éä„ÇπÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    11: { name: '„Ç∑„Éß„Éº„ÉàÂãïÁîª„Éñ„Éº„É†', description: 'Ëª¢Â£≤„ÅåÊàêÂäü„Åô„Çã„Åü„Å≥„Å´+2Ë≥áÈáë„Éú„Éº„Éä„ÇπÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    12: { name: '„ÉÜ„É¨„ÉØ„Éº„ÇØÈúÄË¶Å', description: '‰æ°Ê†º10‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    13: { name: '„Ç§„É≥„Éï„É¨ÈÄ≤Ë°å', description: 'ÂÖ®„Å¶„ÅÆËª¢Â£≤„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ‰æ°Ê†º+2ÔºàÁô∫ÂãïÂæåÊ∞∏Á∂öÔºâ', cost: null },
    14: { name: '„ÉÜ„É¨„ÉØ„Éº„ÇØÈúÄË¶Å', description: '‰æ°Ê†º10‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+1', cost: null },
    15: { name: 'DIY„Éñ„Éº„É†', description: 'ÂÖ®„Å¶„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆÊúÄÊñ∞Ë®≠Ë®à„ÅÆ„ÉÄ„Ç§„ÇπÂÄ§-1', cost: null },
    16: { name: '„Çµ„Çπ„ÉÜ„Éä„Éì„É™„ÉÜ„Ç£', description: '‰ªªÊÑè„ÅÆÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶„Çí+3Ôºà‰ªªÊÑè„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºâ', cost: { prestige: 1 } },
    17: { name: 'Ê±öÊüìÊîπÂñÑ„Ç≠„É£„É≥„Éö„Éº„É≥', description: 'Â∏ÇÂ†¥Ê±öÊüì„É¨„Éô„É´„Çí-2', cost: null },
    18: { name: 'ÁµåÊ∏àÁâπÈúÄ', description: 'ÂÖ®„Éó„É¨„Ç§„É§„Éº„Å´+15Ë≥áÈáë', cost: null }
  };
  
  return effects[sum] || { name: 'ÁÑ°ÂäπÊûú', description: 'Áâπ„Å´Â§âÂåñ„Å™„Åó', cost: null };
};

const executeTrendEffect = (G, effect, playerId) => {
  console.log(`üåü Executing trend effect: ${effect.name}`);
  
  switch (effect.name) {
    case 'ÁµåÊ∏àÁâπÈúÄ':
      for (const pid in G.players) {
        G.players[pid].money += 15;
      }
      console.log('üìà All players gained 15 money');
      break;
      
    case '„Ç§„É≥„Éï„É´„Ç®„É≥„Çµ„ÉºÁ¥π‰ªã':
      const player = G.players[playerId];
      if (player) {
        for (const product of player.personalMarket) {
          product.popularity = Math.min(6, product.popularity + 1);
        }
        console.log(`üì± All products of player ${playerId} gained +1 popularity`);
      }
      break;
      
    case 'Ê±öÊüìÊîπÂñÑ„Ç≠„É£„É≥„Éö„Éº„É≥':
      G.marketPollution = Math.max(0, G.marketPollution - 2);
      console.log(`üå± Market pollution reduced by 2, now: ${G.marketPollution}`);
      break;
      
    case '„ÉÜ„É¨„ÉØ„Éº„ÇØÈúÄË¶Å':
      // ‰æ°Ê†º10‰ª•‰∏ã„ÅÆÂÖ®ÂïÜÂìÅ„ÅÆ‰∫∫Ê∞óÂ∫¶+1
      for (const pid in G.players) {
        for (const product of G.players[pid].personalMarket) {
          if (product.price > 0 && product.price <= 10) {
            product.popularity = Math.min(6, product.popularity + 1);
          }
        }
      }
      for (const product of G.automata.market) {
        if (product.price > 0 && product.price <= 10) {
          product.popularity = Math.min(6, product.popularity + 1);
        }
      }
      console.log('üíª All products with price ‚â§10 gained +1 popularity');
      break;
      
    case '„Ç§„É≥„Éï„É¨ÈÄ≤Ë°å':
      // ÂÖ®„Å¶„ÅÆËª¢Â£≤„Åß„ÅØ„Å™„ÅÑÂïÜÂìÅ„ÅÆ‰æ°Ê†º+2ÔºàÊ∞∏Á∂öÔºâ
      for (const pid in G.players) {
        for (const product of G.players[pid].personalMarket) {
          if (!product.isResale && product.price > 0) {
            product.price += 2;
          }
        }
      }
      for (const product of G.automata.market) {
        if (!product.isResale && product.price > 0) {
          product.price += 2;
        }
      }
      console.log('üí∏ All non-resale products gained +2 price');
      break;
      
    default:
      console.log(`‚ö†Ô∏è Trend effect ${effect.name} not implemented yet`);
  }
};

const server = Server({
  games: [MarketDisruption],
  origins: [
    Origins.LOCALHOST_IN_DEVELOPMENT, 
    Origins.LOCALHOST,
    // NetlifyÊú¨Áï™URLÔºàÂÖ∑‰ΩìÁöÑ„Å™„Éâ„É°„Ç§„É≥Ôºâ
    'https://market-disruption.netlify.app',
    // Netlify„ÅÆ„Éó„É¨„Éì„É•„Éº„Éâ„É°„Ç§„É≥
    /^https:\/\/.*--market-disruption\.netlify\.app$/,
    // ‰∏ÄËà¨ÁöÑ„Å™Netlify„Éâ„É°„Ç§„É≥
    /^https:\/\/.*\.netlify\.app$/,
    // RailwayÊú¨Áï™URL  
    /^https:\/\/.*\.railway\.app$/
  ],
});

// Koa„Éü„Éâ„É´„Ç¶„Çß„Ç¢„Å®„Åó„Å¶Áõ¥Êé•API„É´„Éº„Éà„ÇíËøΩÂä†
server.app.use(async (ctx, next) => {
  // API „É´„Éº„Éà„ÅÆÂá¶ÁêÜ
  if (ctx.path === '/api/status') {
    ctx.type = 'application/json';
    ctx.body = {
      status: 'running',
      version: '2025-07-30-v3-api',
      timestamp: new Date().toISOString(),
      game: 'MarketDisruption',
      availableMoves: Object.keys(MarketDisruption.moves),
      moveCount: Object.keys(MarketDisruption.moves).length,
      criticalMoves: {
        partTimeWork: Object.keys(MarketDisruption.moves).includes('partTimeWork'),
        design: Object.keys(MarketDisruption.moves).includes('design'),
        dayLabor: Object.keys(MarketDisruption.moves).includes('dayLabor'),
        purchase: Object.keys(MarketDisruption.moves).includes('purchase')
      },
      endpoints: [
        'GET /api/status - Server status',
        'GET /api/moves - List all moves'
      ]
    };
    return;
  }
  
  if (ctx.path === '/api/moves') {
    ctx.type = 'application/json';
    const moves = {};
    Object.keys(MarketDisruption.moves).forEach(moveName => {
      moves[moveName] = {
        name: moveName,
        available: true
      };
    });

    ctx.body = {
      moves,
      count: Object.keys(moves).length,
      list: Object.keys(moves),
      criticalMovesCheck: {
        partTimeWork: Object.keys(MarketDisruption.moves).includes('partTimeWork') ? '‚úÖ FOUND' : '‚ùå MISSING',
        design: Object.keys(MarketDisruption.moves).includes('design') ? '‚úÖ FOUND' : '‚ùå MISSING',
        dayLabor: Object.keys(MarketDisruption.moves).includes('dayLabor') ? '‚úÖ FOUND' : '‚ùå MISSING',
        purchase: Object.keys(MarketDisruption.moves).includes('purchase') ? '‚úÖ FOUND' : '‚ùå MISSING'
      }
    };
    return;
  }
  
  // „Åù„ÅÆ‰ªñ„ÅÆÂ†¥Âêà„ÅØÊ¨°„ÅÆ„Éü„Éâ„É´„Ç¶„Çß„Ç¢„Å∏
  await next();
});

console.log('Server origins configured:', [
  'Origins.LOCALHOST_IN_DEVELOPMENT', 
  'Origins.LOCALHOST',
  'https://market-disruption.netlify.app',
  'https://*.netlify.app (regex)',
  'https://*.railway.app (regex)'
]);

const port = process.env.PORT || 8000;

console.log('Starting Market Disruption server with configuration:');
console.log('PORT:', port);
console.log('NODE_ENV:', process.env.NODE_ENV);
console.log('Server version: 2025-07-30-v3-api (Debug API enabled)');

// boardgame.io„Çµ„Éº„Éê„ÉºËµ∑Âãï
server.run(port, () => {
  console.log(`‚úÖ Boardgame.io server successfully running on port ${port}`);
  console.log(`üéÆ Game available at: http://localhost:${port}/games`);
  console.log(`üîó Health check: http://localhost:${port}/games`);
  console.log(`üåê Environment: ${process.env.NODE_ENV || 'development'}`);
  
  // „Éá„Éê„ÉÉ„Ç∞: Âà©Áî®ÂèØËÉΩ„Å™moves„Çí„É≠„Ç∞Âá∫Âäõ
  const moveNames = Object.keys(MarketDisruption.moves);
  console.log(`üéØ Available moves (${moveNames.length}):`, moveNames.join(', '));
  
  // ÂïèÈ°å„ÅÆ„ÅÇ„Çãmoves„ÇíÂÄãÂà•„ÉÅ„Çß„ÉÉ„ÇØ
  const criticalMoves = ['partTimeWork', 'design', 'dayLabor', 'purchase'];
  console.log('üîç Critical moves check:');
  criticalMoves.forEach(move => {
    const exists = moveNames.includes(move);
    console.log(`  - ${move}: ${exists ? '‚úÖ FOUND' : '‚ùå MISSING'}`);
  });
  
  // ÂÆåÂÖ®„Å™ÂïèÈ°åË®∫Êñ≠ÊÉÖÂ†±
  console.log('üîß COMPLETE DIAGNOSTIC INFORMATION:');
  console.log('='.repeat(50));
  console.log(`üìÖ Server Start Time: ${new Date().toISOString()}`);
  console.log(`üåê Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üéØ Game Definition:`, MarketDisruption.name);
  console.log(`üìä Total Moves Available: ${moveNames.length}`);
  console.log(`üìã Complete Move List:`);
  moveNames.forEach((move, index) => {
    console.log(`   ${index + 1}. ${move} ‚úÖ`);
  });
  console.log('='.repeat(50));
  
  // API endpoints are disabled for now - focusing on core game functionality
  console.log('üí° To test moves, use the web interface and check browser console');
  console.log('üåê Game URL: https://market-disruption.netlify.app');
  console.log('üîç If buttons still not working, the issue is browser cache.');
  console.log('‚ö° Solution: Hard refresh (Ctrl+F5) or clear browser cache');
  console.log('='.repeat(50));
}).catch(error => {
  console.error('‚ùå Failed to start server:', error);
  process.exit(1);
});